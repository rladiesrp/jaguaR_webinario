##############################################################################################################
#install.packages("hab", repos = "http://ase-research.org/R/")
#install.packages("hab", repos = "http://ase-research.org/R/", type = "source") #linux
setwd("~/")
#### *******************************************
#### ***       PREPARE THE R LIBRARIES       ***
#### *******************************************
library(adehabitatLT)
library(RMySQL)
library(arules)
library(ggplot2)
library(sp)
library(chron)
library(dplyr)
library(varhandle)
library(adehabitatHR)
library(leaflet)
library (lubridate)
library(outliers)
library (stats)
library(mapproj)
library(hms)
library(stringr)
library(geosphere)
library(randomcoloR)
library(ggrepel)
library(arulesViz)
library("widyr")
library("vcd")
library(shiny)
#### *******************************************
#### ***    INITIALIZE INPUT PARAMETERS      ***
#### *******************************************
### INPUT DATA (user defined parameters):
###   * distRadius: indicates the maximum size of the distance radius, in meters. This value is used to limit the search radius around each
###           location point (latitude/longitude) and time (date/time) of the animal movement to the analysis of the distance between points
###   * min_interval: interval in minutes, used to calculate the occurrence range of the environmental factor;
###   * min_sup:  % mininum of frequency that the set A and B appear in the transaction set. It is calculated using the total
###               frequency divided by total record;
###   * min_conf: % mininum of frequency that B appears in transactions containing A. It is calculated using the Sup value
###               divided by frequency of A;
###   Apriori uses the SupM and ConfM parameters to determine which rules are relevant to the analysis
#### *******************************************
#### ************************************************************************
#### ***                  PREPARA O BANCO DE DADOS                        ***
#### ************************************************************************
conn <- dbConnect(MySQL(),user="root", db="weka",host="localhost")
data <- dbSendQuery(conn, "call PrepareDB();")
#### ************************************************************************
#### ***          LÃŠ ARQUIVO (.CSV) E GRAVA NAS TABELAS DO MsqSQL         ***
#### ************************************************************************
#df  <- read.csv(file=params$data, header=TRUE, sep=",")
#df2 <- read.csv(file=params$data1, header=TRUE, sep=",")
#dbWriteTable(conn, value = df, name = "tb_animal_movement", row.names=F, append = T)
#dbWriteTable(conn, value = df2, name = "tb_fator_ambiente", row.names=F, append = T)
#### ************************************************************************
#### ***            STEP A - IDENTIFY THE ANIMAL BEHAVIOR                 ***
#### ************************************************************************
#############################################################################
## ---->>>>  A1. IDENTIFY THE STATES OF ANIMAL BEHAVIOR
##
## DYNAMIC SCALING CODE FOR USING THE RESIDUAL METHOD OVER A TRACKING DATASET
## Modified from Irina Tolkova, November 2015
## Rachael Orben, November 2015
#############################################################################
# --------------------- LOADING FUNCTIONS AND LIBRARIES ------------------- #
# clear workspace and set working directory
#rm(list = ls())
# load C function, secondary functions, plotting functions
dyn.load("RST_residenceRadii.dll") # if using Windows
source("RST_functions_all.R")
radius <- params$dist
# --------------------- PREPARING DATASET --------------------- #
#dbClearResult(dbListResults(conn)[[1]])
conn <- dbConnect(MySQL(),user="root", db="weka",host="localhost")
data <- dbSendQuery(conn, "select M.individual as band, date as 'Datetime_GMT',  M.lat as 'lat', M.lon as 'lon'
from tb_mov_animal M;")
#conn <- dbConnect(MySQL(),user="root", db="weka",host="localhost")
#data <- dbSendQuery(conn, "SELECT `tb_animal_movement`.`individual.local.identifier` as band, `tb_animal_movement`.`timestamp` as #'Datetime_GMT',  `tb_animal_movement`.`location.long` as 'lon',  `tb_animal_movement`.`location.lat` as 'lat' FROM #tb_animal_movement;")
#armazena os dados numa variavel
origData <- fetch(data, n = -1)
#### ************************************************************************
#### *** RESIDENCE IN SPACE AND TIME METHOD (RST) (TORRES et al., 2017)
#### ************************************************************************
# construct a dataset for analysis (take the band identifiers, longitude, latitude, and time columns from the original data)
# the unique identifier "band" needs to be numeric
dataset <- data.frame("band" = origData$band,
"lat" = origData$lat,
"lon" = origData$lon,
"datetime" = as.POSIXct(origData$Datetime_GMT, "GMT"))
# remove NA lon/lat rows
dataset <- dataset[!is.na(dataset$lon) & !is.na(dataset$lat), ]
#converte as coordenadas de longitude e latitude para valores de coordenadas numa esfera
# create grid x- and y- coordinates from the longitude/latitude coordinates
library(mapproj)
lambert <- mapproject(dataset$lon, dataset$lat, projection = "lambert", parameters = c(mean(dataset$lon), mean(dataset$lat)))
scale <- haversineDist(min(dataset$lon), min(dataset$lat), max(dataset$lon), max(dataset$lat))/projectDist(min(lambert$x), min(lambert$y), max(lambert$x), max(lambert$y), 1)
dataset$x <- lambert$x * scale
dataset$y <- lambert$y * scale
# --------------------- CALCULATING RESIDENCE VALUES --------------------- #
# create a time array: duration of trip in given time units
time_units = "mins" # one of "secs", "mins", "hours", "days", "weeks"
# Certificar-se de que este esta em ordem seq|encial sem valores duplicados
# Raio deve ser escolhido em torno da escala de movimento esperado. Tambim i ztil aumentar a resolugco de incrementos de raios
# Perto de onde a proporgco de pontos de trbnsito cai abaixo de 0,05. Vocj provavelmente precisara executar este uma par de vezes para refinar.
threshold <- rep(0, length(radius))
# determine the different individuals
bandIDs <- unique(dataset$band)
# Para cada faixa, calcule os valores de residjncia
# Se uma faixa nunca sai do raio escolhido, isso resultara em NAs para tempo de residjncia, distbncia e resmduos e um aviso associado.
# Para calculos residenciais e residuais, NA i atribumdo a
# (1) locais no inmcio das faixas ati que o animal se move para alim de R a partir do ponto inicial,
# (2) para os locais no final que estco todos dentro de R do zltimo raio construmdo.
all_tracks = data.frame()
for (i in 1:length(bandIDs)) {
subdata = dataset[dataset$band == bandIDs[i], ]
subdata$time_diff = as.numeric(subdata$datetime - subdata$datetime[1], units = time_units)
result  <- residenceCalc(subdata$x, subdata$y, subdata$time_diff, radius, threshold)
subdata = cbind(subdata, result)
all_tracks = rbind(all_tracks, subdata)
}
#### ************************************************************************
#### ***              END RST METHOD (TORRES et al., 2017)                ***
#### ************************************************************************
#### *****************************************************************************
#### ***  BEHAVIOR CLASSIFICATION BASED ON RESULTS OF THE RST METHOD  (AUTORA) ***
#### *****************************************************************************
colnames(all_tracks)[which(names(all_tracks) == names(select(all_tracks, contains("res"))))] <- "res"
colnames(all_tracks)[which(names(all_tracks) == names(select(all_tracks, contains("band"))))] <- "individual"
colnames(all_tracks)[which(names(all_tracks) == names(select(all_tracks, contains("datetime"))))] <- "timestamp"
all_tracks$res[all_tracks$res == "#N/A"] <- "NA"
all_tracks$res[all_tracks$res =="."] <- ","
all_tracks$estado[all_tracks$res == 0] <- "Transit"
all_tracks$estado[all_tracks$res > 0] <- "Forage"
all_tracks$estado[all_tracks$res < 0] <- "Rest"
all_tracks$estado[is.null(all_tracks$res) == TRUE] <- "NA"
all_tracks$dat = format(as.Date(all_tracks$timestamp), "%Y-%m-%d")
all_tracks$hora = as_hms(as.POSIXct(all_tracks$timestamp, format = "%H:%M:%S"))
all_tracks$dataestadoid = paste(all_tracks$individual, '.', all_tracks$dat, '.', all_tracks$estado, sep = "")
all_tracks$dateid = paste (all_tracks$dat, all_tracks$individual, sep = "")
all_tracks$yearmonid = paste (format(as.Date(all_tracks$timestamp), "%Y-%m"), " | ", all_tracks$individual, sep = "")
all_tracks$yearid = paste (format(as.Date(all_tracks$timestamp), "%Y"),  all_tracks$individual, sep = "")
all_tracks$yearmonidest = paste (format(as.Date(all_tracks$timestamp), "%Y-%m"), " | ", all_tracks$individual, " | ", all_tracks$estado, sep = "")
all_tracks$dateidEst = paste (all_tracks$dat, all_tracks$individual, '.', all_tracks$estado, sep = "")
# CREATE TABLE TO BEHAVIOR STATE
connMove <- dbConnect(MySQL(),user="root", db="weka",host="localhost")
dbWriteTable(connMove, value = all_tracks, name = "TB_RST_MovAnimal_Estado", row.names=F, append = T)
############################################################################################################
#### **************************************************************************************************
#### ***                        GENERATES ANIMAL TRAJECTORIES   AdehabitatLT (CALENGE; ROYER, 2015)
#### **************************************************************************************************
#dsMonk = all_tracks
dsMonk = filter (all_tracks, !(all_tracks$res == "NA" & (all_tracks$res == "Indefined")))
daMonk = as.POSIXct(dsMonk$timestamp, "GMT")
dsM <- as.data.frame(dsMonk)
dsM
#### ******************************************************************************
#### *** ANIMAL TRAJECTORY - RESULT (AUTORA)
#### ******************************************************************************
yearIdTraj = unique(burst(trajMoveYMID))
trajdata = ld(trajMoveYMID)
individual =  unique(trajdata$individual)
groups = as.character(yearIdTraj)
i = 1
map <- leaflet()%>%addTiles     #(Agafonkin, 2019)
palette <- distinctColorPalette(length(individual))
ls = list()
for (i in 1:length(individual)) {
x <- as.character(individual [i])
ls[[x]] = palette[i]
i = i +1
}
i = 1
for (i in 1:length(yearIdTraj)) {
reloc <-summary(trajMoveYMID[i])
if (reloc$nb.reloc >= 5) {
dsM1 = ld(trajMoveYMID[i])
animal  = unique(dsM1[c("individual")])
mindate = min(as.POSIXct(dsM1$date, format = "%y/%m/%d %H:%M"))
maxdate = max(as.POSIXct(dsM1$date, format = "%y/%m/%d %H:%M"))
pointsIniEnd <- filter (dsM1, dsM1$date == mindate | dsM1$date == maxdate )
cor = as.character(ls[animal[,1]])
map <- map%>%addMarkers(lng = ~pointsIniEnd$lon, lat = ~pointsIniEnd$lat,
data =pointsIniEnd,  labelOptions = labelOptions(noHide = T),
label = paste(date(pointsIniEnd$date), "/", pointsIniEnd$estado, sep = ""),
group= burst(trajMoveYMID[i]))
map <- map%>% addPolylines(dsM1$lon, dsM1$lat, labelOptions = labelOptions(noHide = T),
group= burst(trajMoveYMID[i]),  weight= 5, color = cor)
}
}
map %>% addLayersControl(overlayGroups = groups, options = layersControlOptions(collapsed = FALSE))%>% hideGroup(groups)
#### *************************************************************************************
#### ***  A5. IDENTIFY THE HOME RANGE OVERLAP BT ID/MONTH/YEAR (LIST) (CALENGE, 2006)  ***
#### *************************************************************************************
dsM1 = ld(trajMoveYMID)
dsM1
prj <- '+init=epsg:26911'
locationsDD <- SpatialPointsDataFrame(dsM1[c("lon", "lat")], dsM1["individual"], proj4string = CRS(prj))
#UDOI - um mndice de sobreposigco de UD,assume que eles usam o espago independentemente um do outro (Hurlbert, 1978). Valores:
#zero = sem sobreposigco / 1 = (uniformemente distribumdo e tem 100% de sobreposigco)/  > 1 = se ambos os UDs nco forem uniformemente distribumdos e tiverem um alto grau de sobreposigco.
kerneloverlap(locationsDD, grid=1200, percent = 90, meth="UDOI", conditional=FALSE)
#### *************************************************************************************
#### ***                               END (CALENGE, 2006)                             ***
#### *************************************************************************************
#### *************************************************************************************
#### ***  A5. IDENTIFY THE HOME RANGE OVERLAP BT ID/MONTH/YEAR (LIST) (CALENGE, 2006)  ***
#### *************************************************************************************
dsM1 = ld(trajMoveYMID)
prj <- '+init=epsg:26911'
locationsDD <- SpatialPointsDataFrame(dsM1[c("lon", "lat")], dsM1["individual"], proj4string = CRS(prj))
#UDOI - um mndice de sobreposigco de UD,assume que eles usam o espago independentemente um do outro (Hurlbert, 1978). Valores:
#zero = sem sobreposigco / 1 = (uniformemente distribumdo e tem 100% de sobreposigco)/  > 1 = se ambos os UDs nco forem uniformemente distribumdos e tiverem um alto grau de sobreposigco.
kerneloverlap(locationsDD, grid=1200, percent = 90, meth="UDOI", conditional=FALSE)
#### *************************************************************************************
#### ***                               END (CALENGE, 2006)                             ***
#### *************************************************************************************
#### ******************************************************************************
#### ***  A5. IDENTIFY THE HOME RANGE BY BEHAVIORAL ID/MONTH/YEAR (AUTORA)      ***
#### ******************************************************************************
yearIdTraj = unique(burst(trajMoveYMID))
trajdata = ld(trajMoveYMID)
individual =  unique(trajdata$individual)
groups = as.character(yearIdTraj)
i = 1
map <- leaflet()%>%addTiles
palette <- distinctColorPalette(length(individual))
ls = list()
for (i in 1:length(individual)) {
x <- as.character(individual [i])
ls[[x]] = palette[i]
i = i +1
}
for (i in 1:length(yearIdTraj)) {
reloc <-summary(trajMoveYMID[i])
if (reloc$nb.reloc >= 5) {
dsM1 = ld(trajMoveYMID[i])
ano = as.character(unique(paste(substring(burst(trajMoveYMID[i]), 1, 4), sep="")))
mon = as.character(unique(paste(substring(burst(trajMoveYMID[i]), 6, 7), sep="")))
id  = dsM1[c("id")]
animal  = unique(dsM1[c("individual")])
cor = as.character(ls[animal[,1]])
prj <- '+init=epsg:26911'
sp <- SpatialPoints(coords = dsM1[c("lon", "lat")], proj4string = CRS(prj))
kd <- kernelUD(sp)
ud <- getverticeshr(kd, grid= 1200, percent =30)
map <- map%>% addPolygons(data = ud, label = burst(trajMoveYMID[i]), labelOptions = labelOptions(noHide = T),
group= burst(trajMoveYMID[i]),  stroke = TRUE, color = "black", weight = 1, opacity = 0.7,
fillColor = cor,  fillOpacity = 1)
}
}
map %>% addLayersControl(overlayGroups = groups, options = layersControlOptions(collapsed = FALSE))%>% hideGroup(groups)
#### ******************************************************************************
#### ***  A5. IDENTIFY THE HOME RANGE BY BEHAVIORAL STATE/MONTH/YEAR  (AUTORA)  ***
#### ******************************************************************************
yearIdTraj = unique(burst(trajMoveYMIDE))
groups = as.character(yearIdTraj)
i = 1
map <- leaflet()%>%addTiles
for (i in 1:length(yearIdTraj)) {
reloc <-summary(trajMoveYMIDE[i])
if (reloc$nb.reloc >= 5) {
dsM1 = ld(trajMoveYMIDE[i])
ano = as.character(unique(paste(substring(burst(trajMoveYMIDE[i]), 1, 4), sep="")))
mon = as.character(unique(paste(substring(burst(trajMoveYMIDE[i]), 6, 7), sep="")))
id  = dsM1[c("id")]
animal  = unique(dsM1[c("individual")])
cor = as.character(ls[animal[,1]])
prj <- '+init=epsg:26911'
sp <- SpatialPoints(coords = dsM1[c("lon", "lat")], proj4string = CRS(prj))
kd <- kernelUD(sp)
ud <- getverticeshr(kd, grid= 1200, percent =30)
map <- map%>% addPolygons(data = ud, label = burst(trajMoveYMIDE[i]), labelOptions = labelOptions(noHide = T),
group= burst(trajMoveYMIDE[i]),  stroke = TRUE, color = "black", weight = 1, opacity = 0.7,
fillColor = cor,  fillOpacity = 1)
}
}
map %>% addLayersControl(overlayGroups = groups, options = layersControlOptions(collapsed = FALSE))%>% hideGroup(groups)
knit_with_parameters('~/GitHub/AniMoveMiner-master/AniMoveMiner/AniMoveMineR_Code/Algoritmo_AniMoveMineR_English_version.Rmd', encoding = 'UTF-8')
knit_with_parameters('~/GitHub/AniMoveMiner-master/AniMoveMiner/AniMoveMineR_Code/Algoritmo_AniMoveMineR_English_version.Rmd', encoding = 'UTF-8')
#############################################################################################################
### ALGORITHM: Correlation Verification between animal movement data and environmental factors
### *********************************************************************************************************
### INPUT DATA (database): individual <!-- ID animal -->
###                        lat        <!-- Animal position - latitude -->
###                        lon        <!-- Animal position - longitude -->
###                        datetime   <!-- date and time of movement register -->
###
### OUTPUT DATA (ASSOCIATION RULES):
###         basic measures (support and confidence)
###         interest measures (phi/lift)
###         degree dependence (Dep)
###
##############################################################################################################
#install.packages("hab", repos = "http://ase-research.org/R/")
#install.packages("hab", repos = "http://ase-research.org/R/", type = "source") #linux
setwd("~/")
#### *******************************************
#### ***       PREPARE THE R LIBRARIES       ***
#### *******************************************
library(adehabitatLT)
library(RMySQL)
library(arules)
library(ggplot2)
library(sp)
library(chron)
library(dplyr)
library(varhandle)
library(adehabitatHR)
library(leaflet)
library (lubridate)
library(outliers)
library (stats)
library(mapproj)
library(hms)
library(stringr)
library(geosphere)
library(randomcoloR)
library(ggrepel)
library(arulesViz)
library("widyr")
library("vcd")
library(shiny)
#### *******************************************
#### ***    INITIALIZE INPUT PARAMETERS      ***
#### *******************************************
### INPUT DATA (user defined parameters):
###   * distRadius: indicates the maximum size of the distance radius, in meters. This value is used to limit the search radius around each
###           location point (latitude/longitude) and time (date/time) of the animal movement to the analysis of the distance between points
###   * min_interval: interval in minutes, used to calculate the occurrence range of the environmental factor;
###   * min_sup:  % mininum of frequency that the set A and B appear in the transaction set. It is calculated using the total
###               frequency divided by total record;
###   * min_conf: % mininum of frequency that B appears in transactions containing A. It is calculated using the Sup value
###               divided by frequency of A;
###   Apriori uses the SupM and ConfM parameters to determine which rules are relevant to the analysis
#### *******************************************
#### ************************************************************************
#### ***                  PREPARA O BANCO DE DADOS                        ***
#### ************************************************************************
conn <- dbConnect(MySQL(),user="root", db="weka",host="localhost")
data <- dbSendQuery(conn, "call PrepareDB();")
#### ************************************************************************
#### ***            STEP A - IDENTIFY THE ANIMAL BEHAVIOR                 ***
#### ************************************************************************
#############################################################################
## ---->>>>  A1. IDENTIFY THE STATES OF ANIMAL BEHAVIOR
##
## DYNAMIC SCALING CODE FOR USING THE RESIDUAL METHOD OVER A TRACKING DATASET
## Modified from Irina Tolkova, November 2015
## Rachael Orben, November 2015
#############################################################################
# --------------------- LOADING FUNCTIONS AND LIBRARIES ------------------- #
# clear workspace and set working directory
#rm(list = ls())
# load C function, secondary functions, plotting functions
dyn.load("RST_residenceRadii.dll") # if using Windows
source("RST_functions_all.R")
#radius <- params$dist
radius <- 1.935
# --------------------- PREPARING DATASET --------------------- #
#dbClearResult(dbListResults(conn)[[1]])
conn <- dbConnect(MySQL(),user="root", db="weka",host="localhost")
data <- dbSendQuery(conn, "select M.individual as band, date as 'Datetime_GMT',  M.lat as 'lat', M.lon as 'lon'
from tb_mov_animal M;")
#conn <- dbConnect(MySQL(),user="root", db="weka",host="localhost")
#data <- dbSendQuery(conn, "SELECT `tb_animal_movement`.`individual.local.identifier` as band, `tb_animal_movement`.`timestamp` as #'Datetime_GMT',  `tb_animal_movement`.`location.long` as 'lon',  `tb_animal_movement`.`location.lat` as 'lat' FROM #tb_animal_movement;")
#armazena os dados numa variavel
origData <- fetch(data, n = -1)
#### ************************************************************************
#### *** RESIDENCE IN SPACE AND TIME METHOD (RST) (TORRES et al., 2017)
#### ************************************************************************
# construct a dataset for analysis (take the band identifiers, longitude, latitude, and time columns from the original data)
# the unique identifier "band" needs to be numeric
dataset <- data.frame("band" = origData$band,
"lat" = origData$lat,
"lon" = origData$lon,
"datetime" = as.POSIXct(origData$Datetime_GMT, "GMT"))
# remove NA lon/lat rows
dataset <- dataset[!is.na(dataset$lon) & !is.na(dataset$lat), ]
#converte as coordenadas de longitude e latitude para valores de coordenadas numa esfera
# create grid x- and y- coordinates from the longitude/latitude coordinates
library(mapproj)
lambert <- mapproject(dataset$lon, dataset$lat, projection = "lambert", parameters = c(mean(dataset$lon), mean(dataset$lat)))
scale <- haversineDist(min(dataset$lon), min(dataset$lat), max(dataset$lon), max(dataset$lat))/projectDist(min(lambert$x), min(lambert$y), max(lambert$x), max(lambert$y), 1)
dataset$x <- lambert$x * scale
dataset$y <- lambert$y * scale
# --------------------- CALCULATING RESIDENCE VALUES --------------------- #
# create a time array: duration of trip in given time units
time_units = "mins" # one of "secs", "mins", "hours", "days", "weeks"
# Certificar-se de que este esta em ordem seq|encial sem valores duplicados
# Raio deve ser escolhido em torno da escala de movimento esperado. Tambim i ztil aumentar a resolugco de incrementos de raios
# Perto de onde a proporgco de pontos de trbnsito cai abaixo de 0,05. Vocj provavelmente precisara executar este uma par de vezes para refinar.
threshold <- rep(0, length(radius))
# determine the different individuals
bandIDs <- unique(dataset$band)
# Para cada faixa, calcule os valores de residjncia
# Se uma faixa nunca sai do raio escolhido, isso resultara em NAs para tempo de residjncia, distbncia e resmduos e um aviso associado.
# Para calculos residenciais e residuais, NA i atribumdo a
# (1) locais no inmcio das faixas ati que o animal se move para alim de R a partir do ponto inicial,
# (2) para os locais no final que estco todos dentro de R do zltimo raio construmdo.
all_tracks = data.frame()
for (i in 1:length(bandIDs)) {
subdata = dataset[dataset$band == bandIDs[i], ]
subdata$time_diff = as.numeric(subdata$datetime - subdata$datetime[1], units = time_units)
result  <- residenceCalc(subdata$x, subdata$y, subdata$time_diff, radius, threshold)
subdata = cbind(subdata, result)
all_tracks = rbind(all_tracks, subdata)
}
#### ************************************************************************
#### ***              END RST METHOD (TORRES et al., 2017)                ***
#### ************************************************************************
#### *****************************************************************************
#### ***  BEHAVIOR CLASSIFICATION BASED ON RESULTS OF THE RST METHOD  (AUTORA) ***
#### *****************************************************************************
colnames(all_tracks)[which(names(all_tracks) == names(select(all_tracks, contains("res"))))] <- "res"
colnames(all_tracks)[which(names(all_tracks) == names(select(all_tracks, contains("band"))))] <- "individual"
colnames(all_tracks)[which(names(all_tracks) == names(select(all_tracks, contains("datetime"))))] <- "timestamp"
all_tracks$res[all_tracks$res == "#N/A"] <- "NA"
all_tracks$res[all_tracks$res =="."] <- ","
all_tracks$estado[all_tracks$res == 0] <- "Transito"
all_tracks$estado[all_tracks$res > 0] <- "Forrageio"
all_tracks$estado[all_tracks$res < 0] <- "Descanso"
all_tracks$estado[is.null(all_tracks$res) == TRUE] <- "NA"
all_tracks$dat = format(as.Date(all_tracks$timestamp), "%Y-%m-%d")
all_tracks$hora = as_hms(as.POSIXct(all_tracks$timestamp, format = "%H:%M:%S"))
all_tracks$dataestadoid = paste(all_tracks$individual, '.', all_tracks$dat, '.', all_tracks$estado, sep = "")
all_tracks$dateid = paste (all_tracks$dat, all_tracks$individual, sep = "")
all_tracks$yearmonid = paste (format(as.Date(all_tracks$timestamp), "%Y-%m"), " | ", all_tracks$individual, sep = "")
all_tracks$yearid = paste (format(as.Date(all_tracks$timestamp), "%Y"),  all_tracks$individual, sep = "")
all_tracks$yearmonidest = paste (format(as.Date(all_tracks$timestamp), "%Y-%m"), " | ", all_tracks$individual, " | ", all_tracks$estado, sep = "")
all_tracks$dateidEst = paste (all_tracks$dat, all_tracks$individual, '.', all_tracks$estado, sep = "")
# CREATE TABLE TO BEHAVIOR STATE
connMove <- dbConnect(MySQL(),user="root", db="weka",host="localhost")
dbWriteTable(connMove, value = all_tracks, name = "TB_RST_MovAnimal_Estado", row.names=F, append = T)
############################################################################################################
#### **************************************************************************************************
#### ***                        GENERATES ANIMAL TRAJECTORIES   AdehabitatLT (CALENGE; ROYER, 2015)
#### **************************************************************************************************
#dsMonk = all_tracks
dsMonk = filter (all_tracks, !(all_tracks$res == "NA" & (all_tracks$res == "Indefinido")))
daMonk = as.POSIXct(dsMonk$timestamp, "GMT")
dsM <- as.data.frame(dsMonk)
trajStaTime <- as.ltraj(xy =dsMonk[,c("lat", "lon")], date = daMonk, burst = dsMonk$dataestadoid, id = dsMonk$dataestadoid, infolocs = dsMonk[1:21])
trajMoveYMID <- as.ltraj(xy =dsMonk[,c("lat", "lon")], date = daMonk, burst = dsMonk$yearmonid, id = dsMonk$yearmonid, infolocs = dsMonk[1:21])
trajMoveYMIDE <- as.ltraj(xy =dsMonk[,c("lat", "lon")], date = daMonk, burst = dsMonk$yearmonidest, id = dsMonk$yearmonidest, infolocs = dsMonk[1:21])
#### **************************************************************************************************
#### ***                         END AdehabitatLT (CALENGE; ROYER, 2015)
#### **************************************************************************************************
#### **************************************************************************************************
#### A2. IDENTIFY THE PERIODS OF STATES OCCURRENCE PER ANIMAL AND DAY (day/month/year/hour) (AUTORA) **
#### **************************************************************************************************
a = 1
r = 1
lsSeq = list()
for (a in 1:length(trajStaTime)) {
#read trajectories
seqEstado <- ld(trajStaTime [a]);
seqYear = year(seqEstado[1,"date"])
mon = month(seqEstado[1,"date"])
date = format(as.Date(seqEstado[1,"date"]), "%Y-%m-%d")
yearmonid =  seqEstado[1,"yearmonid"]
est = seqEstado[1,"estado"]
yearmonidest = paste(yearmonid, est, sep = "")
idtraj = seqEstado[1,"individual"]
idtraj = as.character(idtraj)
yid = paste(seqYear, idtraj, sep = "")
# generates sequence of hours
seqEst <- c(seqEstado[,"hora"])
seqEst <- chron(times=seqEst)
# initialize var
i = 1
x = 1
tamSeq = length(seqEst)
ls = c()
# segment the hours by continuous intervals
for (i in 1:tamSeq) {
if (x == 1 ){
ls[x] <- as.character(seqEst[i])
x = x + 1
}
if (is.na(seqEst[i+1]) == TRUE) {
ls[x]  <- as.character(seqEst[i])
difTime = difftime(as.POSIXct(max(ls), format = "%H:%M:%S"), as.POSIXct(min(ls), format = "%H:%M:%S"), unit = "mins")
lsSeq[[r]] =  c(idx =  r, burst =  burst(trajStaTime [a]), id=idtraj, estado = est, minSeq = min(ls),
maxSeq = max(ls), yearSeq = seqYear, mon = mon, yearId = yid, date = date, yearmonid= yearmonid,
yearmonidest= yearmonidest, difSeqM = floor(difTime))
r = r +1
}
else {
difMin = abs(as.numeric(difftime(strptime(seqEst[i],"%H:%M:%S"), strptime(seqEst[i+1],"%H:%M:%S"), units="mins")))
if (difMin  < 66){
ls[x] <- as.character(seqEst[i+1])
x = x + 1
} else {
difTime = difftime(as.POSIXct(max(ls), format = "%H:%M:%S"), as.POSIXct(min(ls), format = "%H:%M:%S"),
unit = "mins")
lsSeq[[r]] =  c(idx =  r, burst =  burst(trajStaTime [a]),id=idtraj, estado = est, minSeq = min(ls),
maxSeq = max(ls), yearSeq = seqYear,mon = mon, yearId = yid, date = date, yearmonid= yearmonid,
yearmonidest= yearmonidest, difSeqM = floor(difTime))
r = r +1
ls= c()
x = 1
}
}
}
}
knit_with_parameters('~/GitHub/AniMoveMiner-master/AniMoveMiner/AniMoveMineR_Code/Algoritmo_AniMoveMineR.Rmd', encoding = 'UTF-8')
load("C:/Users/suela/Dropbox/Doutorado - Suelane/Pos_Qualificacao/Estudo de Caso/RST method/S3_Appendix/GHAL_DynScale.rda")
knit_with_parameters('~/GitHub/AniMoveMiner-master/AniMoveMiner/AniMoveMineR_Code/Algoritmo_AniMoveMineR.Rmd', encoding = 'UTF-8')
knit_with_parameters('~/GitHub/AniMoveMiner-master/AniMoveMiner/AniMoveMineR_Code/Algoritmo_AniMoveMineR.Rmd', encoding = 'UTF-8')
setwd("~/GitHub/AniMoveMiner-master/AniMoveMiner")
knit_with_parameters('~/GitHub/AniMoveMiner-master/AniMoveMiner/AniMoveMineR_Code/Algoritmo_AniMoveMineR.Rmd', encoding = 'UTF-8')
View(getSlots)
